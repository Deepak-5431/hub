generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String
  name     String?
  username String? @unique
  avatar   String?
  bio      String? @db.Text
  website  String?
  location String?

  // Social metrics
  followersCount Int @default(0)
  followingCount Int @default(0)
  postsCount     Int @default(0)

  // Account status
  isVerified Boolean @default(false)
  isPrivate  Boolean @default(false)
  isActive   Boolean @default(true)

  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastActiveAt DateTime @default(now())

  // Relations
  posts                 Post[]
  comments              Comment[]
  likes                 Like[]
  stories               Story[]
  followers             Follow[]       @relation("UserFollows")
  following             Follow[]       @relation("UserFollowers")
  sentNotifications     Notification[] @relation("NotificationSender")
  receivedNotifications Notification[] @relation("NotificationReceiver")
  savedPosts            SavedPost[] 

  participants          Participant[]  
  sentMessages          Message[]  

  @@map("users")
}

model Post {
  id       String  @id @default(uuid())
  caption  String? @db.Text
  location String?

  // Media
  imageUrls String[]
  videoUrl  String?
  mediaType MediaType @default(IMAGE)

  // Engagement metrics
  likesCount    Int @default(0)
  commentsCount Int @default(0)
  viewsCount    Int @default(0)

  // Privacy & status
  isArchived Boolean @default(false)
  isHidden   Boolean @default(false)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author   User        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId String
  comments Comment[]
  likes    Like[]
  tags     PostTag[]
  savedBy  SavedPost[]

  @@map("posts")
}

model Comment {
  id         String  @id @default(uuid())
  content    String  @db.Text
  author     User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId   String
  post       Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId     String
  parentId   String?
  likesCount Int     @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Self-relation for nested comments
  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies Comment[] @relation("CommentReplies")

  //  Added missing relation
  likes Like[]

  @@map("comments")
}

model Like {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId String?
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@unique([userId, commentId])
  @@map("likes")
}

model Follow {
  id          String   @id @default(uuid())
  follower    User     @relation("UserFollows", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   User     @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@map("follows")
}

model Story {
  id         String    @id @default(uuid())
  mediaUrl   String
  mediaType  MediaType
  author     User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId   String
  expiresAt  DateTime
  viewsCount Int       @default(0)
  createdAt  DateTime  @default(now())

  @@map("stories")
}

model SavedPost {
  id      String   @id @default(uuid())
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  post    Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId  String
  savedAt DateTime @default(now())

  @@unique([userId, postId])
  @@map("saved_posts")
}

model PostTag {
  id    String @id @default(uuid())
  name  String
  posts Post[]

  @@unique([name])
  @@map("post_tags")
}

model Notification {
  id         String           @id @default(uuid())
  type       NotificationType
  sender     User             @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId   String
  receiver   User             @relation("NotificationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId String
  postId     String?
  commentId  String?
  isRead     Boolean          @default(false)
  createdAt  DateTime         @default(now())

  @@map("notifications")
}

// Enums
enum MediaType {
  IMAGE
  VIDEO
  CAROUSEL
}

enum NotificationType {
  FOLLOW
  LIKE
  COMMENT
  MENTION
  SHARE
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  SYSTEM
}

enum ConversationType {
  DIRECT
  GROUP
}

model Conversation {
  id           String       @id @default(uuid())
  title        String?      // For group chats
  type         ConversationType @default(DIRECT)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  lastMessage  String?
  lastMessageAt DateTime?
  
  // Relations
  participants Participant[]
  messages     Message[]
  
  @@map("conversations")
}

model Participant {
  id             String   @id @default(uuid())
  userId         String
  conversationId String
  role          ParticipantRole @default(MEMBER)
  joinedAt      DateTime @default(now())
  leftAt        DateTime? // When user left group
  mutedUntil    DateTime? // Mute notifications until
  
  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation  Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@unique([userId, conversationId])
  @@map("participants")
}

model Message {
  id             String   @id @default(uuid())
  content        String
  type          MessageType @default(TEXT)
  conversationId String
  senderId       String
  readBy         String[] // Array of user IDs who read the message
  repliedToId   String?   // For message replies
  deletedAt     DateTime? // Soft delete
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Relations
  conversation  Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender        User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  repliedTo     Message? @relation("MessageReplies", fields: [repliedToId], references: [id])
  replies       Message[] @relation("MessageReplies")
  
  @@map("messages")
}

enum ParticipantRole {
  MEMBER
  ADMIN
  OWNER
}